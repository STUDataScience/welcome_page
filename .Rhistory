pacman::p_loaded() # check which packages are loaded
# load and scale data
data("iris")
# scaled data frame of Supply Chain values
dSCM <- data.frame(cbind(scale(iris[1:4]), (iris[,"Species"])))
dSCM <- dplyr::select(dSCM, c(volume = Sepal.Length, # sales volume
holding.cost = Sepal.Width,
stockout.cost = Petal.Length,
shelf.life = Petal.Width,
original.group = V5))
dSCM$ID = seq.int(nrow(dSCM))
rm(iris)
# calc principal components
myPCA    <- prcomp(dSCM[,1:4])
dSCM$PC1 <- myPCA$x[,1]
dSCM$PC2 <- myPCA$x[,2]
# original values prior to clustering
# create plot object using 'factoextra' package
p0 <- fviz_pca_biplot(myPCA, label = "var") +
labs(x = "PC1", y = "PC2") +
ggtitle("Original values prior to clustering, in principal component space") +
theme_bw()
# plot
p0
# function to get the convex hull of each unique point set
#   to draw polygon around clusters
findHull  <- function(df) df[chull(df$PC1, df$PC2),]
# fuzzy k-means (FKM) clustering (using 'fclust' package)
set.seed(93)
fitFKM = FKM(dSCM[,1:4], k=3) # fit clusters
dSCM$FKM.cluster  <- fitFKM$clus[,1] # cluster index
dSCM$FKM.clus.mem <- fitFKM$clus[,2] # cluster membership degree
# get the convex hull of each unique point set for FKM clusters
hulls.FKM <- ddply(dSCM, "FKM.cluster", findHull)
# create plot object
p1 <- ggplot(dSCM, aes(x     = PC1,
y     = PC2,
color = factor(FKM.cluster),
fill  = factor(FKM.cluster),
size  = FKM.clus.mem)) +
geom_point           (alpha = 0.6) +
scale_colour_manual  (name = "Cluster", values = c("red", "green", "blue")) +
scale_fill_manual    (name = "Cluster", values = c("red", "green", "blue")) +
geom_polygon         (data = hulls.FKM , alpha = 0.1, lwd = 0.0001) +
scale_size_continuous(name = "Membership degree", range = c(0,4)) +
# geom_text(aes(y = PC2 + 0.04,
#               x = PC1 + 0.04,
#               label=ID),
#           size = 3,
#           vjust = 0,
#           hjust = 0) +
theme_bw() +
theme(legend.position = "right") +
ggtitle("K-means clusters in principal component space")
# plot
p1
# calc primary and seconday cluster assignment and membership degrees
#####################################################################
# cluster membership degrees
clusMem             <- data.frame(round(fitFKM$U, 3))
colnames(clusMem)   <- paste("mem",
colnames(clusMem),
sep = "_")
# primary cluster index
clusMem$primClus    <- fitFKM$clus[,1]
# primary cluster membership degree
clusMem$primClusMem <- round(fitFKM$clus[,2],3)
# secondary cluster index
clusMem$secClus    <- apply(clusMem,
1,
function(x)
which(rank(x, ties.method = "first")==2))
# secondary cluster membership degree
clusMem$secClusMem <- apply(clusMem,
1,
function(x)
x[which(rank(x, ties.method = "first")==2)])
# add calculated cols of results to table
dSCM           <- cbind(dSCM, clusMem)
# # calc sum of membership across clusters
dSCM$tot       <- rowSums(round(fitFKM$U, 3))
# probability of being in outlier cluster
dSCM$probOut   <- round(1 - dSCM$tot, 3)
# probability of being in a fuzzy cluster
dSCM$probFuzzy <- round(1-clusMem$primClusMem, 3)
# initialize final cluster column with original primary
#   cluster index
dSCM$finalClus <- dSCM$primClus
# calculate gray area membership (i.e. "fuzzy cluster")
#######################################################
# set fuzzy threshhold. Any item that
#  has a probability of being in a fuzzy cluster (probFuzzy)
#  greater than this value will be included
fuzThresh <- 0.40
# row indices of items that have a probability of being in the fuzzy cluster
# greater than set fuzzy threshold
fuzInd <- which(dSCM$probFuzzy > fuzThresh)
# for this example, we are excluding cluster 2 from fuzziness consideration
includedClus <- which(dSCM$primClus != 2)
# which rows are in the fuzzy cluster
fuzRows <- intersect(fuzInd, includedClus)
# assign these rows to the fuzzy cluster
dSCM$finalClus[fuzRows] <- "fuzzy"
# get convex hull for final clusters
hulls.Fuzzy <- ddply(dSCM, "finalClus", findHull)
# create plot object
p2 <- ggplot(dSCM, aes(x     = PC1,
y     = PC2,
color = factor(finalClus),
fill  = factor(finalClus),
size  = FKM.clus.mem)) +
geom_point(alpha = 0.6) +
scale_colour_manual(name = "Cluster",
values = c("red", "green", "blue", "black")) +
scale_fill_manual  (name = "Cluster",
values = c("red", "green", "blue", "black")) +
geom_polygon(data = hulls.Fuzzy , alpha = 0.1, lwd = 0.0001) +
scale_size_continuous(name = "Membership degree", range = c(0,4)) +
# geom_text(aes(y = PC2 + 0.04,
#               x = PC1 + 0.04,
#               label=ID),
#           size = 3,
#           vjust = 0,
#           hjust = 0) +
theme_bw() +
theme(legend.position = "right") +
ggtitle("K-means clusters in principal component space, with fuzzy cluster")
# plot
p2
# plot all in one view
grid.arrange(p1, p2, ncol = 1)
# plot which labels the rows in the fuzzy cluster
#################################################
# create new column with values for fuzzy cluster
# otherwise, NA
dSCM$fuzClusID <- NA
dSCM$fuzClusID[fuzRows] <- dSCM$ID[fuzRows]
# create plot object
p3 <- ggplot(dSCM, aes(x     = PC1,
y     = PC2,
color = factor(finalClus),
fill  = factor(finalClus),
size  = FKM.clus.mem)) +
geom_point(alpha = 0.6) +
scale_colour_manual(name = "Cluster",
values = c("red", "green", "blue", "black")) +
scale_fill_manual  (name = "Cluster",
values = c("red", "green", "blue", "black")) +
geom_polygon(data = hulls.Fuzzy , alpha = 0.1, lwd = 0.0001) +
scale_size_continuous(name = "Membership degree", range = c(0,4)) +
# geom_text(aes(y = PC2 + 0.04,
#               x = PC1 + 0.04,
#               label = fuzClusID),
#           size = 3,
#           vjust = 0,
#           hjust = 0) +
theme_bw() +
theme(legend.position = "right") +
ggtitle("K-means with fuzzy cluster and row IDs")
# use ggrepel for cleaner labeling
p3 <- p3 + geom_text_repel(aes(y = PC2 ,
x = PC1 ,
label = fuzClusID),
size = 3,
point.padding = unit(1e-01, "lines"))
# plot
p3
# Interactive plot using plotly
# https://plot.ly/r/text-and-annotations/
p10 <- dSCM %>%
plot_ly(x = PC1, y = PC2, mode = "markers", color = finalClus, size = probFuzzy,
hoverinfo = "text",
text = paste("ID = ", dSCM$ID, "Fuzzy Cluster Prob = ", dSCM$probFuzzy)) %>%
layout(title ="K-means with fuzzy cluster")
p10
# summary table to inspect fuzzy cluster probability
dSCM.fuz <- dSCM[fuzRows, c("ID",
"mem_Clus.1",
"mem_Clus.2",
"mem_Clus.3",
"probFuzzy")]
# end
###########################################################
# extra content; plot of original groups from Iris data set;
#   regular k-means from stats package
# get the convex hull of each unique point set to draw polygon
hulls.original <- ddply(dSCM, "original.group", findHull)
# plots of original product groups
##################################
# create plot object
p0 <- ggplot(dSCM, aes(x = PC1
, y =  PC2
, color = factor(original.group)
, fill  = factor(original.group))) +
geom_point() +
scale_colour_manual(values = c("red", "green", "blue")) +
scale_fill_manual(values = c("red", "green", "blue")) +
geom_polygon(data = hulls.original, alpha = 0.1) +
geom_text(aes(y = PC2 + 0.04,
x = PC1 + 0.04,
label = ID),
size = 3,
vjust = 0,
hjust = 0) +
theme_bw() +
theme(legend.position = "right") +
ggtitle("Plot of original product groups in principal component space")
# plot
p0
# plot all in one view
grid.arrange(p0, p1, p2, p3, ncol = 2)
seq(1,99,by=5)
reg.data<-read.csv("tannin.cvs")
reg.data<-read.csv("tannin.csv")
attach(reg.data)
names(reg.data)
monday <- searchTwitter("#MondayMotivation", n = 1500)
#save text
monday_text <- sapply(monday, function(x) x$getText())
#create corpus
monday_text_corpus <- Corpus(VectorSource(monday_text))
install.packages("wordcloud")
library(wordcloud)
wordcloud(monday_text_corpus)
head(monday_text)
head(monday_text)
# make data frame
monday_df <- twListToDF(monday)
View(monday_df)
users_monday <- monday_df$screenName
users_monday_df <- twListToDF(lookupUsers(users_monday))
View(users_monday_df)
cr7 <- getUser("cristiano")
cr7_friends <- cr7$getFriends()
cr7 <- getUser("cristiano")
cr7_friends <- cr7$getFriends()
# make cr7 friends a data fram
cr7_friends_df <- twListToDF(cr7_friends)
View(cr7_friends_df)
setwd("~/Google Drive/welcome_page/")
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
getwd()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
library(picante)
setwd("~/Downloads/bioMaul/")
# read file
biomaul <- read.csv("otu_table_mc2_NO_tax_no_pynast_failures_for_R.csv")
dim(biomaul)
head(biomaul[1:5,])
head(colnames(biomaul))
m <- nrow(biomaul)
n <- ncol(biomaul)
# omit first colum
bioAmanda <- biomaul[, 2:n]
dim(bioAmanda)
# check total abundance
apply(bioAmanda, 1, sum)
# Turn percent cover to relative abundance by dividing each value by sample
# total abundance
bioAmanda <- decostand(bioAmanda, method = "total")
# check total abundance in each sample
apply(bioAmanda, 1, sum)
# look at the transformed data
bioAmanda[1:5, 1:5]
plot(bioAmanda[,1],bioAmanda[,2])
pairs(bioAmanda[1:100, 1:10])
metadata <- read.csv("DEEPEND_samples_VR_trial.csv")
head(metadata[15:25,])
ourcolumns <- c(1,9:12)
head(metadata[15:25, ourcolumns])
myOTU <- biomaul[,1]
IDsamples <- colnames(bioAmanda)
head(IDsamples)
IDinmetada <- metadata[,1]
head(IDinmetada)
# find samplesID
keepthese <- IDsamples %in%  IDinmetada
length(keepthese)
# we want to keep the columns where keepthese is TRUE only
# we want to keep the columns where keepthese is TRUE only
newData <- bioAmanda[, keepthese]
# compare species richness
trial <- rowSums(t(bioAmanda[,keepthese]>0))
metaSamples <-  metadata$Day_night[2:nrow(metadata)]
boxplot(trial ~ metaSamples)
# compare species richness
metaSamples <-  metadata$Day_night[2:nrow(metadata)]
boxplot(specnumber(t(bioAmanda[,keepthese])) ~ metaSamples, ylab = "# of sequences")
metaSamples <-  metadata$BottleOrder[2:nrow(metadata)]
# keep only columns for which we have metadata
reducedData <- bioAmanda[,keepthese]
boxplot(specnumber(t(reducedData)) ~ metaSamples, ylab = "insert good label here")
help("read.tree")
phy <- read.tree("rep_set.tre")
class(phy)
phy
# list the elements of our phylogeny
names(phy)
# list the elements of our phylogeny
names(phy)
### root
print("tree was rooted to the longest edge before tips were removed")
longest.edge <- which.max(phy$edge.length)
longest.edge
long.nodes <- phy$edge[longest.edge,]
long.nodes
new.outgroup <- long.nodes[long.nodes < Ntip(phy)]
new.outgroup
phy.rooted <- root(phy, outgroup=new.outgroup, resolve.root=T)   ### one rooting method
phy.rooted
class(phy.rooted)
class(phy.rooted)
names(phy.rooted)
phy.rooted
phy.rooted
phy
phy.rooted
# list the elements of our phylogeny
names(phy.rooted)
phy.rooted
# list the elements of our phylogeny
names(phy.rooted)
# what are the first few tip labels?
phy$tip.label[1:5]
# what are the first few tip labels?
phy.rooted$tip.label[1:5]
# how many tips does our phylogeny have?
Ntip(phy.rooted)
# plot our phylogeny (the cex argument makes the labels small enough to
# read)
plot(phy.rooted, cex = 0.5)
library(ape)
fit<-hclust(phy.rooted,method='ward')
library(ape)
fit<-hclust(phy.rooted,method='ward.D')
library(ape)
fit<-hclust(phy.rooted,method='ward.D2')
library(ape)
fit<-hclust(phy.rooted)
plot(phy.rooted, type="fan", edge.width=2, edge.color="purple", cex = 0.5)
help("specnumber")
View(metadata)
help("boxplot")
setwd("/Users/reisanar/Google Drive/welcome_page")
getwd()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
help(userTimeline)
??userTimeline
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/HomesForSale.csv")
mydata <- read.csv(text = mydata_url)
mroz.dat <- read.table("http://socserv.mcmaster.ca/jfox/Books/Applied-Regression-3E/datasets/Mroz.txt")
summary(mroz.dat)
library(tidyverse)
glimpse(mroz.dat)
table(mroz.dat$lfp, mroz.dat$wc)
table(mroz.dat$lfp, mroz.dat$hc)
mroz.logit <- glm(lfp ~ k5 + k618 + age + wc + hc + lwg + inc,
data = mroz.dat,
family = binomial(link = "logit"))
summary(mroz.logit)
summary(mroz.logit)
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/oneway.csv")
oneway <- read.csv(text = mydata_url)
attach(oneway)
names(oneway)
View(oneway)
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/oneway.txt")
oneway <- read.table(text = mydata_url)
attach(oneway)
names(oneway)
View(oneway)
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/oneway.txt")
oneway <- read.csv(text = mydata_url)
attach(oneway)
names(oneway)
View(oneway)
help("read.csv")
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/oneway.txt")
oneway <- read.csv(text = mydata_url, sep = "")
attach(oneway)
names(oneway)
tapply(Growth,Photoperiod,mean)
Photoperiod<-ordered(Photoperiod,levels=c("Very.short","Short","Long","Very.long"))
tapply(Growth,Photoperiod,mean)
tapply(Growth,Photoperiod,mean)
is.factor(Photoperiod)
one.way<-aov(Growth~Photoperiod)
one.way<-aov(Growth~Photoperiod)
# getsummary of model
summary(one.way)
plot(one.way)
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/breastCancer.csv")
gapCleaned <- read.csv(text = mydata_url)
means<- round(tapply(gapCleaned$breastcancer, gapCleaned$continent, mean), digits=2)
means
library(gplots)  #load the "gplots" package to plot means
plotmeans(gapCleaned$breastcancer~gapCleaned$continent, digits=2, ccol="red", mean.labels=T, main="Plot of breast cancer means by continent")
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/breastCancer.csv")
gapCleaned <- read.csv(text = mydata_url)
attach(gapCleaned)
library(RCurl)
mydata_url <- getURL("https://raw.githubusercontent.com/reisanar/datasets/master/breastCancer.csv")
gapCleaned <- read.csv(text = mydata_url)
attach(gapCleaned)
means<- round(tapply(breastcancer, continent, mean), digits=2)
means
library(gplots)  #load the "gplots" package to plot means
plotmeans(breastcancer ~ continent, digits=2, ccol="red", mean.labels=T, main="Plot of breast cancer means by continent")
means<- round(tapply(breastcancer, continent, mean), digits=2)
means
library(gplots)  #load the "gplots" package to plot means
plotmeans(breastcancer ~ continent, digits=2, ccol="red", mean.labels=T, main="Plot of breast cancer means by continent")
means<- round(tapply(breastcancer, continent, mean), digits=2)
means
library(gplots)  #load the "gplots" package to plot means
plotmeans(breastcancer ~ continent, digits=2, ccol="red", mean.labels=T, main="Plot of breast cancer means by continent")
boxplot(breastcancer ~ continent, main="Breast cancer by continent (mean is black dot)", xlab="continents", ylab="new cases per 100,00 residents", col=rainbow(7))
points(means, col="black", pch=18)
aov_cont<- aov(breastcancer ~ continent)
summary(aov_cont)   # here we see results for the ANOVA test
tuk<- TukeyHSD(aov_cont)
tuk
plot(tuk)
chocolate <-  data.frame(
flavor =
c(5, 7, 3,
4, 2, 6,
5, 3, 6,
5, 6, 0,
7, 4, 0,
7, 7, 0,
6, 6, 0,
4, 6, 1,
6, 4, 0,
7, 7, 0,
2, 4, 0,
5, 7, 4,
7, 5, 0,
4, 5, 0,
6, 6, 3
),
theType = factor(rep(c("A", "B", "C"), 15)),
taster = factor(rep(1:15, rep(3, 15)))
)
tapply(chocolate$flavor, chocolate$theType, mean)
theModel <- lm(chocolate$flavor ~ chocolate$theType + chocolate$taster)
summary(theModel)
anova(theModel)
a1 <- aov(chocolate$flavor ~ chocolate$theType + chocolate$taster)
posthoc <- TukeyHSD(x=a1, 'chocolate$theType', conf.level=0.95)
posthoc
str(Orange)
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
# set our working directory
setwd("~/Google Drive/welcome_page/")
# render your site
rmarkdown::render_site()
